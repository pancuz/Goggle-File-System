Goggle-File-System
==================

Emulation of Goggle File System - a distributed system with M clients and N File Servers and a Master server. the M-server maintains the following metadata about files in your file system: file name, names of Linux files that correspond to the chunks of the file, which server hosts which chunk, when was a chunk to server mapping last updated.  the M-server does not have the chunk name to server mapping, nor does it have the corresponding time of last mapping update. Every 5 seconds, the servers send heartbeat messages to the M-server with the list of Linux files they store. The M-server uses these heartbeat messages to populate/update the metadata. If the M-server does not receive a heartbeat message from a server for 15 seconds, the M-server assumes that the server is down and none of its chunks is available.  Clients wishing to create a file, read or append to a file in your file system send their request (with the name of the file) to the M-server. If a new file is to be created, the M-server randomly asks one of the servers to create the first chunk of the file, and adds an entry for that file in its directory. For read and append operations, based on the file name and the offset, the M-server determines the chunk, and the offset within that chunk where the operation has to be performed, and sends the information to the client. Then, the client directly contacts the corresponding server and performs the operations. In effect, clients and servers communicate with each other to exchange data, while the clients and servers communicate with the M-server to exchange metadata. The maximize amount of data that can be appended at a time is 2048 bytes. If the current size of the last chunk of the file, where the append operation is to be performed, is S such that 8192 ô€€€ S &lt; appended data size then the rest of that chunk is padded with a null character, a new chunk is created and the append operation is performed there. If all replicas of a chunk are consistent before an append, then they must be consistent on completion of the append.  In order to ensure replica consistency, if two clients concurrently submit append operations for the same chunk, the two appends should be applied in the same sequence at all the replicas of the chunk.  A read operation can be performed at any of the three replicas. If a chunk server, X, crashes, thus reducing the number of replicas of the chunks hosted by it by one, for each chunk stored on X, the M-server must identify a live chunk server, Y , and create one new copy of that chunk on Y . You must not copy all chunks previously hosted by X to a single live chunk server, Y . Instead, the responsibility should be distributed among a subset of live chunk servers. Make sure that a chunk server that already has a replica of a chunk stored on X does not get a second replica of the same chunk.  When assigning a chunk to a chunk server (either when a new chunk is created or while handling the failure of a chunk server), the M-server tries to achieve load balancing. For this purpose, each chunk server sends information about how many chunks it is already hosting and how much free space it has. The M-server uses this information to determine where a chunk is to be placed.
